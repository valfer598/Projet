import openpyxl as op
import difflib
import unicodedata
import os

# === PARAMÈTRES ===
nom_fichier = "LB3_SiteX.xlsx"  # <-- à adapter selon ton fichier
nom_feuille = "LB3"

wb = op.load_workbook(nom_fichier)
ws = wb[nom_feuille]

# Liste des machines extraites
machines = []

# === FONCTIONS UTILITAIRES ===

def ajout_machine():
    """Crée un dictionnaire machine vide avec les champs normalisés."""
    return {
        'NOM_DU_SITE': None,
        'BATIMENT': None,
        'ETAGE': None,
        'LT': None,
        'BAIE': None,
        'CONSTRUCTEUR': None,
        'MODELE': None,
        'SENS INSTALLATION': None,
        'ETIQUETTE': None,
        'POSITION V': None,
        'POSITION H': None,
        'SN': None,
        'CAB': None,
        'REMARQUE': None
    }

def nettoyer(val):
    """Nettoie une valeur texte brute."""
    if val:
        return str(val).strip().replace("\n", "").replace("\r", "").lower()
    return ""

def normaliser(texte):
    """Supprime les accents, met en minuscule et nettoie."""
    texte = texte.lower().strip()
    texte = unicodedata.normalize("NFKD", texte).encode("ASCII", "ignore").decode("utf-8")
    return texte

def detecter_approx(texte, liste_mots, seuil=0.8):
    """Renvoie une correspondance approximative d’un mot dans une liste."""
    if not texte:
        return None
    texte_normalise = normaliser(texte)
    mots = texte_normalise.split()
    liste_normalisee = [normaliser(m) for m in liste_mots]
    for mot in mots:
        match = difflib.get_close_matches(mot, liste_normalisee, n=1, cutoff=seuil)
        if match:
            return match[0]
    return None

def extraire_modele_depuis_prefixe(texte, liste_prefixes):
    """Extrait un modèle si le texte contient un mot commençant par un préfixe."""
    if not texte:
        return None
    mots = normaliser(texte).split()
    for i, mot in enumerate(mots):
        for prefixe in liste_prefixes:
            if normaliser(mot).startswith(normaliser(prefixe)):
                return " ".join(mots[i:])
    return None

def chercher_valeur_apres_libelle(libelle):
    """Cherche une valeur située juste après un libellé dans le tableau."""
    libelle_nettoye = nettoyer(libelle)
    for i in range(1, ws.max_row + 1):
        for j in range(1, ws.max_column):
            val = ws.cell(row=i, column=j).value
            if nettoyer(val) == libelle_nettoye:
                return ws.cell(row=i, column=j + 1).value
    return None

def remplir_champ_depuis_colonne(champ_excel, champ_machine, transformer=None):
    """Remplit un champ machine à partir d’une colonne Excel."""
    mot_cle_nettoye = nettoyer(champ_excel)
    for j in range(1, ws.max_column + 1):
        val = ws.cell(row=1, column=j).value
        if nettoyer(val) == mot_cle_nettoye:
            for i, machine in enumerate(machines):
                ligne_excel = i + 2
                valeur = ws.cell(row=ligne_excel, column=j).value
                machine[champ_machine.upper()] = transformer(valeur) if transformer else valeur
            return
    print(f"[⚠] Colonne '{champ_excel}' non trouvée.")

def detecter_colonnes_par_prefixe(prefixe):
    """Renvoie les numéros de colonnes dont l’en-tête commence par le préfixe donné."""
    prefixe_nettoye = nettoyer(prefixe)
    colonnes = []
    for j in range(1, ws.max_column + 1):
        val = ws.cell(row=1, column=j).value
        if val and nettoyer(val).startswith(prefixe_nettoye):
            colonnes.append(j)
    return colonnes

def Etage(val):
    """Convertit la valeur brute d’étage en notation standard."""
    val = nettoyer(val).upper()
    correspondances = {
        "RDC": "RDC",
        "1": "R+1", "R+1": "R+1",
        "2": "R+2", "R+2": "R+2",
        "3": "R+3", "R+3": "R+3"
    }
    return correspondances.get(val, f"Étage inconnu ({val})")

# === EXTRACTION DES MACHINES ===

prefixe_baie = ""  # Laisser vide si les baies n’ont pas de préfixe spécifique
constructeurs = ["Cisco", "HP", "Dell", "Juniper", "Fortinet", "Palo Alto"]
modeles = ["C9300", "DL380", "EX4300", "FG60", "PA-220"]

colonnes_baie = detecter_colonnes_par_prefixe(prefixe_baie)
positions_par_contenu = {}

for col_baie in colonnes_baie:
    nom_baie = ws.cell(row=1, column=col_baie).value

    for i in range(2, ws.max_row + 1):
        val_baie = ws.cell(row=i, column=col_baie).value
        position = ws.cell(row=i, column=col_baie - 1).value
        sens_installation = ws.cell(row=i, column=col_baie + 1).value

        if not val_baie or not str(val_baie).strip():
            continue

        texte = str(val_baie).strip()
        if texte not in positions_par_contenu:
            positions_par_contenu[texte] = []

        positions_par_contenu[texte].append({
            "position": position,
            "baie": nom_baie,
            "sens": sens_installation
        })

# === CONSTRUCTION DES MACHINES ===

for contenu, infos in positions_par_contenu.items():
    constructeur = detecter_approx(contenu, constructeurs)
    modele = extraire_modele_depuis_prefixe(contenu, modeles)

    for info in infos:
        machine = ajout_machine()
        machine["POSITION V"] = info["position"]
        machine["SENS INSTALLATION"] = info["sens"]
        machine["BAIE"] = info["baie"]
        machine["CONSTRUCTEUR"] = constructeur or "Inconnu"
        machine["MODELE"] = modele or "Non identifié"
        machines.append(machine)

# === REMPLISSAGE DES CHAMPS COMMUNS ===

val_bat = chercher_valeur_apres_libelle("batiment")
val_etage = chercher_valeur_apres_libelle("etage")

if val_bat:
    for machine in machines:
        machine["BATIMENT"] = val_bat
else:
    remplir_champ_depuis_colonne("batiment", "BATIMENT")

if val_etage:
    for machine in machines:
        machine["ETAGE"] = Etage(val_etage)
else:
    remplir_champ_depuis_colonne("etage", "ETAGE", transformer=Etage)

# === AJOUT DU NOM DU SITE ET DE LA FEUILLE ===

nom_site = os.path.splitext(os.path.basename(nom_fichier))[0]
for machine in machines:
    machine["NOM_DU_SITE"] = nom_site
    machine["LT"] = nom_feuille

# === AFFICHAGE DU RÉSULTAT FINAL ===

for m in machines:
    if m["CONSTRUCTEUR"] == "Inconnu":
        print(f"\033[91mBaie:\033[0m {m['BAIE']} \033[91m{m['POSITION V']}\033[0m : aucune correspondance\n")
    else:
        print(m, "\n")
